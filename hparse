#!/bin/sh

export IFS=' 	
'
SYSPATH=$(command -p getconf PATH 2>/dev/null)
export PATH="${SYSPATH:-/bin:/usr/bin}${PATH:+:$PATH}"
export LC_ALL=C
progname=$(basename "$0")

usage(){
	cat <<EOF
usage: $progname [file...]
EOF
}
print_help(){
	usage
	cat <<EOF

OPTIONS
	-h	print this help
EOF
}
error(){
	printf '%s: %s\n\n' "$progname" "$1" 1>&2
	usage 1>&2
	exit ${2:-1}
}

# for sed 
LF='
'
CR=$(printf '\r')
# marker of original newline.
GS=$(printf '\035') 
# used as field separater in inter
RS=$(printf '\036')

while getopts h opt; do
	case "$opt" in
	h)	print_help;exit 0;;
	?)	usage 1>&2;exit 1;;
	esac
done
shift $((OPTIND - 1))

cat -- ${1+"$@"} |
	sed -- '
		s/\\/\\\\/g
		s/'"$CR"'/\\r/g
		s/$/'"$GS"'/
		s:</\{0,1\}[0-9a-zA-Z]\{1,\}:\'"$LF"'&\'"$LF"':g
		s:['\''">=]:\'"$LF"'&\'"$LF"':g' |
	sed '/^$/d' |
	#
	# categorize strings into types
	# types
	# - startTag
	# - attrName
	# - attrVal
	# - endTag
	# - voidElement
	# - text
	#
	awk -v fieldSep="$RS" -v newline="$GS" '
		BEGIN{
			# enum states
			inQuote  = 0 # -- inside a quote inside a tag.
			             #    Its type is attrVal.
			attrVal  = 1 # -- after "=" inside a tag.
			attrName = 2 # -- befor "=" inside a tag.
			text     = 3 # -- outside a tag.

			# initial state
			state = text

			quote=""
			initText = 1

			# If the last attrNames of a tag is slash(/), then
			# the tag provides a void element. This value knows
			# that its latest attrName is slash, if it is 1.
			maybeVoidElement=0
		}
		function printType(type){
			printf("%s%s", type, fieldSep)
		}
		###########################################
		# text -- outside a tag or inside a quote #
		###########################################
		text == state{
			if($0 ~ /^<\/[0-9a-zA-Z]+/){
				# print newline when texts exist
				printf("%s", initText ? "" :"\n")
				initText = 1

				printType("endTag")
				sub(/^<\//,"",$0);printf("%s\n", $0)
				state = attrName
				next
			}else if($0 ~ /^<[0-9a-zA-Z]+/){
				printf("%s", initText ? "" : "\n")
				initText = 1

				printType("startTag")
				sub(/^</,"",$0);printf("%s\n", $0)
				state = attrName
				next
			}

			if(initText){
				printType("text")
				initText = 0
			}
			printf("%s", $0)
			next
		}
		inQuote == state{
			if($0 == quote){
				printf("\n")
				state = attrName
				next
			}
			printf("%s", $0)
			next
		}
		#######################################
		# inside a tag -- attrVal or attrName #
		#######################################
		{	
			# remove the marker of newlines.
			# because a newline inside tag is just separator.
			gsub(newline,"")
		}
		/^[ 	]*$/{
			# This is just separator.
			next
		}
		attrVal == state{
			printType("attrVal")
			if($0 == "'\''" || $0 == "\""){
				# single- or double-quoted attribute value
				quote = $0
				state = inQuote
				next
			}
			# unquoted attribute value
			printf("%s\n", $1)

			# Rest fields are attrName.
			# list ups those.
			state = attrName
			for(i=2; i<=NF; i++){
				if($i == "/"){
					maybeVoidElement=1
					continue
				}
				maybeVoidElement=0
				printType("attrName")
				printf("%s\n", $i)
			}
			next
		}
		attrName == state{
			if($0 == ">"){
				if(maybeVoidElement){
					printType("voidElement")
					printf("\n")
				}
				maybeVoidElement=0
				state = text
				next
			}else if($0 == "="){
				state = attrVal
				next
			}

			for(i=1; i<=NF; i++){
				if($i == "/"){
					maybeVoidElement=1
					continue
				}
				maybeVoidElement=0
				printType("attrName")
				printf("%s\n", $i)
			}
			next
		}
		END{
			if((text == state && initText == 0)|| inQuote == state){
				printf("\n")
			}
		}' |
	awk -v fieldSep="$RS" '
		BEGIN{
			FS=fieldSep
		}
		{
			print $1,$2
		}' |
	sed 's/'"$GS"'/\\n/g'
